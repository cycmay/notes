## C++多线程

### 互斥量和锁

`std::unique_lock::lock` 和 `std::unique_lock::unlock`
上锁操作，调用它所管理的 Mutex 对象的 lock 函数。如果在调用 Mutex 对象的 lock 函数时该 Mutex 对象已被另一线程锁住，则当前线程会被阻塞，直到它获得了锁。

### 条件变量 condition_variable 

1.  `void wait (unique_lock& lck);` 无条件被阻塞。调用该函数前，当前线程应该已经对unique_lock lck完成了加锁。所有使用同一个条件变量的线程必须在wait函数中使用同一个unique_lock。该wait函数内部会自动调用lck.unlock()对互斥锁解锁，使得其他被阻塞在互斥锁上的线程恢复执行。使用本函数被阻塞的当前线程在获得通知(notified，通过别的线程调用 notify_*系列的函数）而被唤醒后，wait()函数恢复执行并自动调用lck.lock()对互斥锁加锁。

2.  `template void wait (unique_lock& lck, Predicate pred);`带条件的被阻塞。wait函数设置了谓词（Predicate），只有当pred条件为false时调用该wait函数才会阻塞当前线程，并且在收到其他线程的通知后只有当pred为true时才会被解除阻塞。因此，等效于while (!pred()) wait(lck);

### 线程入口函数

一般情况下，我们使用全局函数或者类的静态函数作为线程函数入口；但是以上2者都不能访问类的非静态成员变量。
使用类的成员函数，作为线程入口函数。使该线程入口函数能够访问类的成员变量。

```cpp
class MyClass {
    int fun(int a) {
    ...
    }
}
int main() {
    MyClass MyObject;
    int a = 2;
    // 第一个参数传入函数名，第二个参数传入类实例的地址(this), 第三个参数开始传入函数参数；
    thread my_thread(MyClass::fun, &MyObject, a); 
}
```

## 生产者消费者模型

多个消费者和多个生产者的问题。生产者不断的向仓库放入产品，消费者不断的从仓库取出产品，仓库的容量是有限的。因此，当仓库处于满状态时，生产者必须等待消费者取出 1 个或多个产品后才能继续生产；同理，当仓库处于空状态时，消费者必须等待生产者将产品放入仓库后才能消费（取出）产品。

**问题1，产品队列满与空**

使用数组模拟仓库，需要记录下一次生产和消费在数组中的位置。
用生产和消费在数组中的位置判断仓库是否为空或者为满：
假设仓库容量为 N：

-   `(produce_position+1)%N == consume_position` 满
    因为初始位置都是 0，当两者相差一个位置时，定义满状态。（最多存储N-1个)
-   `consume_position == produce_position` 空 

**问题2，多个消费者与生产者如何阻塞与唤醒**

当仓库满时，阻塞生产者；当一个消费行为后，仓库非满，唤醒生产者；
当仓库空时，阻塞消费者；当一个生产行为后，仓库非空，唤醒消费者；
因此需要引入，仓库满条件变量和仓库空条件变量。

由于生产和消费行为都会修改数据，因此两者操作必须互斥，需引入生产消费互斥锁。
当我们要生产（或消费）一定数量的产品时，需要计数判断是否已经完成工作；多个生产者进行生产时，都会对生产的计数变量进行修改，因此需引入**生产计数互斥锁**和**消费计数互斥锁**，保证同时只有一个生产（或消费）进程对计数变量进行修改。



